<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <script>
      window.__CP_DEBUG = {{ CP_DEBUG|tojson }};
      if (!window.__CP_DEBUG) { try { console.debug = function(){} } catch(e){} }
    </script>
    <title>Settings</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  </head>
  <body class="p-4">
    {% include '_ribbon.html' %}

    <div class="container py-4">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <h1 class="h3">Settings</h1>
      </div>

      <form id="settingsForm" class="card p-3" action="/settings" method="post">
        <input type="hidden" id="perf_initial" value='{{ perf|tojson }}'>
        <div class="mb-3">
          <label class="form-label">Days to import</label>
          <input type="number" name="days" id="days" class="form-control" value="{{ days }}">
        </div>
        <div class="mb-3">
          <label class="form-label">Maximum puzzles to keep (0 = unlimited)</label>
          <input type="number" name="max_puzzles" id="max_puzzles" class="form-control" value="{{ max_puzzles|default(0) }}" min="0">
        </div>
        <div class="mb-3">
          <label id="perfLabel" class="form-label">Time controls</label>
          <div id="perfCheckboxes" class="form-check" role="group" aria-labelledby="perfLabel">
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="perf_classical" name="perf" value="classical" aria-label="Time control Classical">
              <label class="form-check-label" for="perf_classical">Classical</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="perf_rapid" name="perf" value="rapid" aria-label="Time control Rapid">
              <label class="form-check-label" for="perf_rapid">Rapid</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="perf_blitz" name="perf" value="blitz" aria-label="Time control Blitz">
              <label class="form-check-label" for="perf_blitz">Blitz</label>
            </div>
          </div>
        </div>
        <div class="mb-3">
          <label id="tagLabel" class="form-label">Puzzle tags</label>
          <div id="tagCheckboxes" class="form-check" role="group" aria-labelledby="tagLabel">
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="tag_blunder" name="tags" value="Blunder" aria-label="Tag Blunder">
              <label class="form-check-label" for="tag_blunder">Blunder</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="tag_mistake" name="tags" value="Mistake" aria-label="Tag Mistake">
              <label class="form-check-label" for="tag_mistake">Mistake</label>
            </div>
            <div class="form-check form-check-inline">
              <input class="form-check-input" type="checkbox" id="tag_inaccuracy" name="tags" value="Inaccuracy" aria-label="Tag Inaccuracy">
              <label class="form-check-label" for="tag_inaccuracy">Inaccuracy</label>
            </div>
          </div>
        </div>
        <div class="mb-3">
          <p id="puzzleCounts" class="text-muted">Loading puzzle counts...</p>
        </div>
        <div class="mb-3">
          <label for="max_attempts" class="form-label">Maximum incorrect attempts: <span id="max_attempts_value">{{ max_attempts|default(3) }}</span></label>
          <div style="max-width: 400px;">
            <input type="range" class="form-range" min="1" max="3" step="1" id="max_attempts" name="max_attempts" value="{{ max_attempts|default(3) }}">
          </div>
          <div class="form-text">Number of attempts allowed before revealing the solution. XP is halved for each incorrect attempt.</div>
        </div>
        {% if max_puzzles_warning %}
        <div class="alert alert-warning" role="alert" id="maxPWarning">
          Your maximum puzzle limit is low â€” older puzzles will be deleted when new ones are imported.
        </div>
        {% endif %}
        <div class="mb-3 form-check">
          <input class="form-check-input" type="checkbox" id="use_spaced" name="use_spaced">
          <label class="form-check-label" for="use_spaced">Use spaced repetition</label>
          <div class="form-text">When enabled, puzzles are selected using the spaced repetition algorithm. When disabled puzzles are selected at random.</div>
        </div>
        <div class="mb-3">
          <label class="form-label">Cooldown between repeats (minutes)</label>
          <input type="number" name="cooldown" id="cooldown" class="form-control" value="{{ cooldown }}">
          <div class="form-text">Minimum time before a puzzle can be shown again.</div>
        </div>
      </form>
    </div>

    <script src="/static/vendor/jquery-3.6.0.min.js"></script>
    <script src="/static/vendor/bootstrap.bundle.min.js"></script>
    <script src="/static/js/ribbon.js"></script>
  <script>
      // initialize ribbon after DOM load
      window.addEventListener('DOMContentLoaded', ()=>{ if (window.initRibbon) window.initRibbon();
  // Pre-check boxes based on server-provided perf (hidden input holds either JSON array or CSV string)
  const perfInitialEl = document.getElementById('perf_initial');
  let perfItems = [];
  if (perfInitialEl && perfInitialEl.value) {
    try {
      const parsed = JSON.parse(perfInitialEl.value);
      if (Array.isArray(parsed)) perfItems = parsed.map(s=>String(s).trim().toLowerCase()).filter(Boolean);
      else if (typeof parsed === 'string') perfItems = parsed.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
    } catch(e) {
      // fall back to CSV parsing
      perfItems = perfInitialEl.value.split(',').map(s=>s.trim().toLowerCase()).filter(Boolean);
    }
  }
  if (perfItems.includes('classical')) document.getElementById('perf_classical').checked = true;
  if (perfItems.includes('rapid')) document.getElementById('perf_rapid').checked = true;
  if (perfItems.includes('blitz')) document.getElementById('perf_blitz').checked = true;
  // Pre-check tag boxes from server-provided tags variable
  try {
    const serverTags = {{ tags|tojson|default('[]') }};
    if (Array.isArray(serverTags)) {
      if (serverTags.map(s=>String(s).toLowerCase()).includes('blunder')) document.getElementById('tag_blunder').checked = true;
      if (serverTags.map(s=>String(s).toLowerCase()).includes('mistake')) document.getElementById('tag_mistake').checked = true;
      if (serverTags.map(s=>String(s).toLowerCase()).includes('inaccuracy')) document.getElementById('tag_inaccuracy').checked = true;
    }
  } catch(e) { /* ignore templating/runtime issues */ }
  // Pre-check spaced-repetition checkbox (default to disabled for new setup)
  try {
    const useSpaced = {{ use_spaced|tojson|default('false') }};
    const el = document.getElementById('use_spaced');
    if (el) el.checked = !!useSpaced;
  } catch(e) { }
  
  // Update cooldown field state based on spaced repetition checkbox
  function updateCooldownState() {
    const useSpacedChecked = document.getElementById('use_spaced').checked;
    const cooldownInput = document.getElementById('cooldown');
    cooldownInput.disabled = !useSpacedChecked;
    if (!useSpacedChecked) {
      cooldownInput.classList.add('text-muted');
    } else {
      cooldownInput.classList.remove('text-muted');
    }
  }
  
  // Initialize cooldown state on load
  updateCooldownState();
  
  // Update cooldown state when spaced repetition checkbox changes
  document.getElementById('use_spaced').addEventListener('change', updateCooldownState);
      });

  // helper to fetch counts from backend and update UI
  async function refreshCounts(){
    const checked = Array.from(document.querySelectorAll('#perfCheckboxes input[type=checkbox]:checked')).map(i=>i.value);
    const tagChecked = Array.from(document.querySelectorAll('#tagCheckboxes input[type=checkbox]:checked')).map(i=>i.value);
    const params = new URLSearchParams();
    for (const p of checked) params.append('perf', p);
    for (const t of tagChecked) params.append('tags', t);
    try{
      const r = await fetch('/api/puzzle_counts?'+params.toString());
      if (r.ok){
        const j = await r.json();
        const el = document.getElementById('puzzleCounts');
        el.textContent = `${j.available} puzzles available from a total of ${j.total}`;
      }
    }catch(e){
      // ignore
    }
  }

  // refresh counts on load and whenever checkboxes change
  window.addEventListener('DOMContentLoaded', ()=>{ 
    // checkbox change handlers
    Array.from(document.querySelectorAll('#perfCheckboxes input[type=checkbox], #tagCheckboxes input[type=checkbox]')).forEach(function(ch){
      ch.addEventListener('change', ()=>{ refreshCounts(); });
    });
    // initial fetch
    refreshCounts();
  });

      // Update max attempts slider value display
      const maxAttemptsSlider = document.getElementById('max_attempts');
      const maxAttemptsValue = document.getElementById('max_attempts_value');
      if (maxAttemptsSlider && maxAttemptsValue) {
        maxAttemptsSlider.addEventListener('input', ()=>{
          maxAttemptsValue.textContent = maxAttemptsSlider.value;
        });
      }

      // Auto-save function
      async function saveSettings() {
        const days = document.getElementById('days').value;
        const cooldown = document.getElementById('cooldown').value;
        const maxP = document.getElementById('max_puzzles').value;
        const maxAttempts = document.getElementById('max_attempts').value;
        const checked = Array.from(document.querySelectorAll('#perfCheckboxes input[type=checkbox]:checked')).map(i=>i.value);
        const tagChecked = Array.from(document.querySelectorAll('#tagCheckboxes input[type=checkbox]:checked')).map(i=>i.value);
        const payload = { 
          days: days, 
          perf: checked, 
          cooldown: cooldown, 
          tags: tagChecked, 
          max_puzzles: maxP, 
          use_spaced: !!document.getElementById('use_spaced').checked, 
          max_attempts: maxAttempts 
        };
        
        try {
          await fetch('/settings', { 
            method: 'POST', 
            headers: {'Content-Type':'application/json'}, 
            body: JSON.stringify(payload)
          });
        } catch(e) {
          console.error('Failed to save settings:', e);
        }
      }

      // Add auto-save listeners to all form inputs
      window.addEventListener('DOMContentLoaded', ()=>{ 
        const autoSaveInputs = [
          document.getElementById('days'),
          document.getElementById('cooldown'),
          document.getElementById('max_puzzles'),
          document.getElementById('max_attempts'),
          document.getElementById('use_spaced')
        ];
        
        // Auto-save on input change (with debounce for text inputs)
        autoSaveInputs.forEach(input => {
          if (input) {
            if (input.type === 'checkbox') {
              input.addEventListener('change', saveSettings);
            } else if (input.type === 'range') {
              input.addEventListener('change', saveSettings);
            } else {
              // Debounce text/number inputs
              let timeout;
              input.addEventListener('input', () => {
                clearTimeout(timeout);
                timeout = setTimeout(saveSettings, 1000);
              });
            }
          }
        });
        
        // Auto-save on checkbox changes
        Array.from(document.querySelectorAll('#perfCheckboxes input[type=checkbox], #tagCheckboxes input[type=checkbox]')).forEach(ch => {
          ch.addEventListener('change', saveSettings);
        });
      });
    </script>
  </body>
</html>